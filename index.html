<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Random φ³/φ⁴ Feynman Diagram Generator</title>
  <script src="https://unpkg.com/cytoscape/dist/cytoscape.min.js"></script>
  <style>
    body {
      font-family: 'Segoe UI', 'Arial', sans-serif;
      background: linear-gradient(135deg, #f8fafc 0%, #e0e7ef 100%);
      margin: 0;
      min-height: 100vh;
      color: #222;
    }
    .container {
      max-width: 900px;
      margin: 40px auto;
      background: #fff;
      border-radius: 18px;
      box-shadow: 0 8px 32px rgba(60,80,120,0.10), 0 1.5px 6px rgba(60,80,120,0.06);
      padding: 36px 40px 32px 40px;
    }
    h3 {
      font-size: 2.1rem;
      font-weight: 700;
      letter-spacing: 0.01em;
      margin-top: 0;
      margin-bottom: 18px;
      color: #2b3a5a;
      text-align: center;
      text-shadow: 0 1px 0 #f0f4fa;
    }
    .controls {
      display: flex;
      justify-content: center;
      gap: 32px;
      margin-bottom: 22px;
      flex-wrap: wrap;
    }
    .controls label {
      font-size: 1.08rem;
      background: #f3f6fa;
      border-radius: 6px;
      padding: 7px 16px 7px 12px;
      box-shadow: 0 1px 2px rgba(60,80,120,0.04);
      cursor: pointer;
      transition: background 0.2s;
      user-select: none;
      display: flex;
      align-items: center;
      gap: 7px;
    }
    .controls label:hover {
      background: #e6ecf5;
    }
    .controls input[type="checkbox"] {
      accent-color: #3b82f6;
      width: 18px;
      height: 18px;
      margin-right: 5px;
    }
    #generate {
      display: block;
      margin: 0 auto 18px auto;
      padding: 11px 38px;
      font-size: 1.15rem;
      font-weight: 600;
      color: #fff;
      background: linear-gradient(90deg, #3b82f6 60%, #6366f1 100%);
      border: none;
      border-radius: 8px;
      box-shadow: 0 2px 8px rgba(60,80,120,0.08);
      cursor: pointer;
      transition: background 0.18s, box-shadow 0.18s;
      letter-spacing: 0.01em;
    }
    #generate:hover, #generate:focus {
      background: linear-gradient(90deg, #2563eb 60%, #7c3aed 100%);
      box-shadow: 0 4px 16px rgba(60,80,120,0.13);
      outline: none;
    }
    #stats {
      text-align: center;
      font-size: 1.08rem;
      margin: 12px 0 18px 0;
      color: #374151;
      background: #f3f6fa;
      border-radius: 6px;
      padding: 8px 0;
      letter-spacing: 0.01em;
      min-height: 1.5em;
      box-shadow: 0 1px 2px rgba(60,80,120,0.04);
    }
    #cy {
      width: 100%;
      max-width: 800px;
      height: 500px;
      border: 1.5px solid #d1d5db;
      border-radius: 12px;
      margin: 0 auto;
      background: #f8fafc;
      box-shadow: 0 2px 8px rgba(60,80,120,0.07);
      display: block;
      transition: box-shadow 0.2s;
    }
    @media (max-width: 950px) {
      .container {
        max-width: 98vw;
        padding: 18px 6vw 18px 6vw;
      }
      #cy {
        max-width: 98vw;
      }
    }
    @media (max-width: 600px) {
      .container {
        padding: 10px 2vw 10px 2vw;
      }
      h3 {
        font-size: 1.3rem;
      }
      .controls {
        gap: 10px;
      }
      #cy {
        height: 320px;
      }
    }
  </style>
</head>
<body>

<div class="container">
  <h3>Random Feynman Diagram</h3>

  <div class="controls">
    <label><input type="checkbox" id="allowTadpole" checked /> allow tadpole</label>
    <label><input type="checkbox" id="allowPhi3" checked /> allow φ³</label>
    <label><input type="checkbox" id="allowPhi4" checked /> allow φ⁴</label>
    <label><input type="checkbox" id="allowExternalLegs" checked /> allow external legs</label>
  </div>

  <button id="generate">Generate</button>
  <p id="stats"></p>
  <button id="showSymmetry" style="display:none; margin: 0 auto 18px auto; padding: 8px 24px; font-size: 1rem; font-weight: 500; color: #fff; background: linear-gradient(90deg, #6366f1 60%, #3b82f6 100%); border: none; border-radius: 8px; box-shadow: 0 2px 8px rgba(60,80,120,0.08); cursor: pointer;">Show Symmetry Factor</button>
  <div id="symmetryFactor" style="display:none; text-align:center; font-size:1.15rem; margin-bottom:12px; color:#4b5563;"></div>
  <div id="cy"></div>
</div>

<script>
/********************
 * Global parameters
 ********************/
const PARAMS = {
  minVertices: 2,
  maxVertices: 6,
  maxExternalLegs: 4,
  multiEdgeCurve: 120
};

let cy = cytoscape({
  container: document.getElementById('cy'),
  style: [
    {
      selector: 'node',
      style: {
        'width': 14,
        'height': 14,
        'background-color': '#000',
        'label': '',
        'overlay-opacity': 0
      }
    },
    {
      selector: 'edge',
      style: {
        'line-color': '#000',
        'curve-style': 'bezier',
        'control-point-distance': 'data(curve)',
        'width': 2,
        'overlay-opacity': 0
      }
    },
    {
      selector: 'node.external',
      style: {
        'background-color': 'rgba(255, 255, 255, 1)',
        'width': 10,
        'height': 10,
        'border-width': 2,
        'border-color': 'rgba(0, 0, 0, 1)',
        'label': '',
        'opacity': 1
      }
    },
    {
      selector: 'edge.external-leg',
      style: {
        'line-color': 'rgba(0, 0, 0, 1)',
        'width': 2,
        // 'line-style': 'dashed'
      }
    }
  ],
  panningEnabled: false,
  userPanningEnabled: false
});

/********************
 * Utility functions
 ********************/
function randomInt(a, b) {
  return Math.floor(Math.random() * (b - a + 1)) + a;
}

function shuffle(arr) {
  for (let i = arr.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [arr[i], arr[j]] = [arr[j], arr[i]];
  }
}

/********************
 * Connectivity check
 ********************/
function isConnected(vertices, edges) {
  if (vertices.length === 0) return true;
  const adj = {};
  vertices.forEach(v => adj[v.id] = []);
  edges.forEach(e => {
    adj[e.source].push(e.target);
    adj[e.target].push(e.source);
  });

  const visited = new Set();
  const stack = [vertices[0].id];

  while (stack.length) {
    const v = stack.pop();
    if (visited.has(v)) continue;
    visited.add(v);
    adj[v].forEach(u => {
      if (!visited.has(u)) stack.push(u);
    });
  }
  return visited.size === vertices.length;
}

/********************
 * Diagram generator
 ********************/
function generateDiagram(opts) {
  let diagram;
  let attempts = 0;
  const MAX_ATTEMPTS = 1000; // Prevent infinite loops

  do {
    attempts++;
    if (attempts > MAX_ATTEMPTS) {
      throw new Error('Failed to generate diagram: too many attempts (possibly impossible constraints)');
    }

    const V = randomInt(PARAMS.minVertices, PARAMS.maxVertices);
    const vertices = [];
    for (let i = 0; i < V; i++) vertices.push({ id: 'v' + i });

    const allowed = [];
    if (opts.allowPhi3) allowed.push(3);
    if (opts.allowPhi4) allowed.push(4);
    if (allowed.length === 0) throw new Error('No interaction allowed');

    // Assign degrees and stubs
    const stubs = [];
    vertices.forEach(v => {
      const deg = allowed[randomInt(0, allowed.length - 1)];
      for (let i = 0; i < deg; i++) stubs.push(v.id);
    });

    // Randomly select number of external legs, but only accept if parity matches
    let numExternalLegs, parityAttempts = 0, MAX_PARITY_ATTEMPTS = 100;
    const totalStubs = stubs.length;
    do {
      numExternalLegs = randomInt(0, PARAMS.maxExternalLegs);
      parityAttempts++;
      if (parityAttempts > MAX_PARITY_ATTEMPTS) break;
    } while ((totalStubs - numExternalLegs) % 2 !== 0 || numExternalLegs > totalStubs);

    if (numExternalLegs > totalStubs) continue; // skip impossible cases

    // Shuffle stubs and set aside external legs
    let stubsCopy = stubs.slice();
    shuffle(stubsCopy);
    let externalLegs = stubsCopy.splice(0, numExternalLegs);

    // Try to pair remaining stubs without tadpoles
    let internalEdges = [];
    let stubAttempts = 0;
    const MAX_STUB_ATTEMPTS = 500;
    let success = false;
    while (stubAttempts < MAX_STUB_ATTEMPTS) {
      stubAttempts++;
      let tempStubs = stubsCopy.slice();
      shuffle(tempStubs);
      let tempEdges = [];
      let valid = true;
      while (tempStubs.length >= 2) {
        const a = tempStubs.pop();
        const b = tempStubs.pop();
        if (!opts.allowTadpole && a === b) {
          valid = false;
          break;
        }
        tempEdges.push({ source: a, target: b });
      }
      if (valid && tempStubs.length === 0) {
        internalEdges = tempEdges;
        success = true;
        break;
      }
    }
    if (!success) continue;

    // Count external legs per vertex
    const externalPerVertex = Array(vertices.length).fill(0);
    externalLegs.forEach(vId => {
      const idx = vertices.findIndex(v => v.id === vId);
      if (idx >= 0) externalPerVertex[idx]++;
    });

    diagram = { vertices, internalEdges, externalLegs, externalPerVertex };
  } while (!isConnected(diagram.vertices, diagram.internalEdges)
           || diagram.externalLegs.length > PARAMS.maxExternalLegs);

  return diagram;
}

/********************
 * Symmetry factor
 ********************/
function symmetryFactor(diagram) {
  const n = diagram.vertices.length;

  // build adjacency matrix A and external vector e
  const index = {};
  diagram.vertices.forEach((v, i) => index[v.id] = i);

  const A = Array.from({ length: n }, () => Array(n).fill(0));
  diagram.internalEdges.forEach(e => {
    const i = index[e.source];
    const j = index[e.target];
    if (i === j) {
      A[i][i] += 1;
    } else {
      A[i][j] += 1;
      A[j][i] += 1;
    }
  });

  const ext = Array(n).fill(0);
  // external legs are distinguished: ext[i] already fixed per vertex
  if (diagram.externalPerVertex) {
    diagram.externalPerVertex.forEach((v, i) => ext[i] = v);
  }

  // generate all permutations of [0,...,n-1]
  function permute(arr) {
    if (arr.length <= 1) return [arr];
    const res = [];
    for (let i = 0; i < arr.length; i++) {
      const rest = arr.slice(0, i).concat(arr.slice(i + 1));
      for (const p of permute(rest)) {
        res.push([arr[i]].concat(p));
      }
    }
    return res;
  }

  const perms = permute([...Array(n).keys()]);

  let aut = 0;

  for (const pi of perms) {
    let ok = true;

    // check external legs
    for (let i = 0; i < n; i++) {
      if (ext[i] !== ext[pi[i]]) { ok = false; break; }
    }
    if (!ok) continue;

    // check adjacency matrix
    for (let i = 0; i < n && ok; i++) {
      for (let j = 0; j < n; j++) {
        if (A[i][j] !== A[pi[i]][pi[j]]) { ok = false; break; }
      }
    }

    if (ok) aut++;
  }

  // local edge factors
  let edgeFactor = 1;
  function fact(k) { let r = 1; for (let i = 2; i <= k; i++) r *= i; return r; }

  for (let i = 0; i < n; i++) {
    // tadpoles
    if (A[i][i] > 0) edgeFactor *= fact(A[i][i]) * (2 ** A[i][i]);
    for (let j = i + 1; j < n; j++) {
      if (A[i][j] > 0) edgeFactor *= fact(A[i][j]);
    }
  }

  return aut * edgeFactor;
}

/********************
 * Drawing
 ********************/
function drawDiagram(diagram) {
  const elements = [];

  diagram.vertices.forEach((v, i) => {
    const angle = 2 * Math.PI * i / diagram.vertices.length;
    elements.push({
      data: { id: v.id },
      position: {
        x: 400 + 150 * Math.cos(angle),
        y: 250 + 150 * Math.sin(angle)
      }
    });
  });

  // Group multi-edges by unordered node pairs
  const edgeGroups = {};
  diagram.internalEdges.forEach((e, i) => {
    // Sort source and target to treat (a,b) and (b,a) as the same group
    const key = [e.source, e.target].sort().join('-');
    if (!edgeGroups[key]) edgeGroups[key] = [];
    edgeGroups[key].push({ ...e, idx: i });
  });

  // Assign curve values for each group
  Object.values(edgeGroups).forEach(group => {
    const n = group.length;
    const base = PARAMS.multiEdgeCurve;
    group.forEach((edge, j) => {
      let curve = 0;
      if (n > 1) {
        if (n % 2 == 0) {
          // Generate a symmetric, positive curve pattern:
          // Example for n=4: [180, 60, 60, 180] if base=120
          const center = n / 2 - 0.5;
          curve = Math.abs(j - center) * base;
        } else {
          // Generate a symmetric, positive curve pattern: [N*base, (N-1)*base, ..., 0, ..., (N-1)*base, N*base]
          // Example for n=5: [240, 120, 0, 120, 240] if base=120
          const center = Math.floor(n / 2);
          curve = Math.abs(j - center) * base;
        }
      }
      elements.push({
        data: {
          id: 'e' + edge.idx,
          source: edge.source,
          target: edge.target,
          curve: curve
        }
      });
    });
  });


  // Draw external legs: for each external leg, add a new external node and an edge from the vertex to this node
  if (diagram.externalLegs && diagram.externalLegs.length > 0) {
    // Count how many external legs are attached to each vertex
    const extLegsByVertex = {};
    diagram.externalLegs.forEach((vId, i) => {
      if (!extLegsByVertex[vId]) extLegsByVertex[vId] = [];
      extLegsByVertex[vId].push(i);
    });

    diagram.externalLegs.forEach((vId, i) => {
      const extId = 'ext' + i;
      // Find the vertex index for angle placement
      const vIdx = diagram.vertices.findIndex(v => v.id === vId);
      const baseAngle = 2 * Math.PI * vIdx / diagram.vertices.length;
      // Spread external legs around the parent node if multiple are attached
      const siblings = extLegsByVertex[vId];
      const nSiblings = siblings.length;
      const myIdx = siblings.indexOf(i);
      // Spread in a small arc (e.g., ±25 degrees)
      const spread = Math.PI / 6; // 30 degrees total
      let angle = baseAngle;
      if (nSiblings > 1) {
        angle = baseAngle + spread * (myIdx - (nSiblings - 1) / 2) / (nSiblings > 1 ? (nSiblings - 1) : 1);
      }
      elements.push({
        data: { id: extId },
        position: {
          x: 400 + 200 * Math.cos(angle),
          y: 250 + 200 * Math.sin(angle)
        },
        classes: 'external'
      });
      elements.push({
        data: {
          id: 'leg' + i,
          source: vId,
          target: extId,
          curve: 0
        },
        classes: 'external-leg'
      });
    });
  }


  cy.elements().remove();
  cy.add(elements);
  cy.fit();

  // --- Sync external node positions when internal node is moved ---
  // Store offset between internal and external nodes at drag start
  let extOffsets = {};
  cy.nodes().not('.external').on('grab', function(evt) {
    const node = evt.target;
    extOffsets[node.id()] = [];
    node.connectedEdges().forEach(function(edge) {
      const extNode = edge.target().hasClass('external') ? edge.target() : (edge.source().hasClass('external') ? edge.source() : null);
      if (extNode) {
        const dx = extNode.position('x') - node.position('x');
        const dy = extNode.position('y') - node.position('y');
        extOffsets[node.id()].push({ extId: extNode.id(), dx, dy });
      }
    });
  });
  cy.nodes().not('.external').on('position', function(evt) {
    const node = evt.target;
    const offsets = extOffsets[node.id()];
    if (!offsets) return;
    offsets.forEach(function(offset) {
      const extNode = cy.getElementById(offset.extId);
      if (extNode && extNode.nonempty()) {
        extNode.position({
          x: node.position('x') + offset.dx,
          y: node.position('y') + offset.dy
        });
      }
    });
  });
  cy.nodes().not('.external').on('free', function(evt) {
    const node = evt.target;
    delete extOffsets[node.id()];
  });

  // Hide symmetry factor and show the button
  document.getElementById('symmetryFactor').style.display = 'none';
  document.getElementById('showSymmetry').style.display = 'block';

  // Store symmetry factor for later reveal
  const S = symmetryFactor(diagram);
  document.getElementById('symmetryFactor').textContent = `Symmetry factor: ${S}`;

  document.getElementById('stats').textContent =
    `Vertices: ${diagram.vertices.length}, ` +
    `Internal edges: ${diagram.internalEdges.length}, ` +
    `External legs: ${diagram.externalLegs ? diagram.externalLegs.length : 0} (max ${PARAMS.maxExternalLegs})`;

  console.log('Generated diagram:', JSON.stringify(diagram, null, 2));
}

/********************
 * UI hook
 ********************/

document.getElementById('generate').onclick = () => {
  const opts = {
    allowTadpole: document.getElementById('allowTadpole').checked,
    allowPhi3: document.getElementById('allowPhi3').checked,
    allowPhi4: document.getElementById('allowPhi4').checked,
    allowExternalLegs: document.getElementById('allowExternalLegs').checked
  };
  // Hide symmetry factor and button until new diagram is drawn
  document.getElementById('symmetryFactor').style.display = 'none';
  document.getElementById('showSymmetry').style.display = 'none';
  // Set PARAMS.maxExternalLegs depending on option
  const prevMaxExternalLegs = PARAMS.maxExternalLegs;
  PARAMS.maxExternalLegs = opts.allowExternalLegs ? 4 : 0;
  const d = generateDiagram(opts);
  drawDiagram(d);
  PARAMS.maxExternalLegs = prevMaxExternalLegs; // restore for next time
};

document.getElementById('showSymmetry').onclick = () => {
  document.getElementById('symmetryFactor').style.display = 'block';
  document.getElementById('showSymmetry').style.display = 'none';
};

/********************
 * Basic sanity tests
 ********************/
// simple connectivity test
console.assert(
  isConnected([{id:'a'},{id:'b'}],[{source:'a',target:'b'}]) === true,
  'Connectivity test failed'
);
</script>

</body>
</html>
